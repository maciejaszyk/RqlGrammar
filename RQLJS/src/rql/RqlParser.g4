parser grammar RqlParser;
options { tokenVocab = RqlLexer; }

/*
    Please do not insert any new rule between existing code. If you want add additional rule you must do it at the end.
    Our SyntaxErrorHandler operates on Enum generated by current model! When you add new rule between existing ruels
    it moves all enums ids after new rule by +1
 */

prog:
    (jsFunction)* 
    fromStatement 
    loadStatement? 
    whereStatement? 
    groupByStatement? 
    orderByStatement? 
    includeStatement?
    selectStatement? 
    EOF
    ;

fromStatement:
     FROM collectionName fromAlias? #CollectionByName 
    |FROM INDEX indexName fromAlias? #CollectionByIndex
    |FROM ALL_DOCS #AllCollections 
    ;

indexName:
    STRING;

loadStatement:
    LOAD 
    variable 
    alias
    ;

selectStatement:
    //  Select only individual fields e.g. "select Column1, Column2"
     SELECT DISTINCT?
        (parameterWithOptionalAlias | specialFunctions)
    (
        COMMA 
        (
            (parameterWithOptionalAlias | specialFunctions)
        )
    )* #ProjectIndividualFields
    |SELECT jsCode #javascriptCode
    ;

jsFunction: 
    (JS_FUNCTION_DECLARATION WORD OP_PAR WORD (COMMA WORD)* CL_PAR) //definition declare func(X,...y)
    jsCode
    ;

jsCode:
    '{' jsCode '}'
    | .*?;


//tree with alias name in second node
alias:
    AS WORD
    ;

//Capture variable name (also accept aliased names).
variable:
    (
        WORD 
        (OP_Q CL_Q)? 
        DOT 
    )? 
    WORD
        ;

//Function definition. It accept custom_function with aliases, params or param-free.
custom_function:
    (
        variable 
        OP_PAR 
        (
            (
                custom_function
                |variable
                |STRING+
                |NUM
            ) //Parser would throw when comma occures at first place in parenthesis
            (
                COMMA 
                (
                    custom_function
                    |variable
                    |STRING+
                    |NUM
                )
            )*
        )? 
        CL_PAR
    )
        ;

whereStatement:
    WHERE expr
    ; 

groupByStatement:
    GROUP_BY 
    (
        parameterWithOptionalAlias
    )
    (
        COMMA 
        (
            parameterWithOptionalAlias
        )
    )*
    ;

orderByStatement:
    ORDER_BY 
        (
            parameterWithOptionalAlias
        )
        (
            COMMA 
            (
                parameterWithOptionalAlias
            )
        )* 
        orderBySorting?
        SORTING?
    ;

//Order sorting option keyword.
orderBySorting:
    AS 
    (
        STRING_W 
        |ALPHANUMERIC
        |LONG 
        |DOUBLE
    );

expr:
    specialFunctions #SpecialFunctionExpr
    | OP_PAR expr CL_PAR #ParentissExpr
    | expr EQUAL expr #EqualExpr
    | expr MATH expr #MathOperatorExpr
    | expr BETWEEN expr AND expr #BetweenExpr
    | expr AND NOT? expr #AndExpr
    | expr OR NOT? expr #OrExpr
    | expr  ALL? IN expr #ListExpr
    | COMMA? STRING+ expr? #WordValueExpr
    | NUM #NumExpr
    | (FALSE | TRUE) #BooleanExpr
    | custom_function #FunctionExpr
    | variable #VariableExpr
    ;

//Functions like morelikethis() or intersect()
specialFunctions:
    (
        FACET
        |BOOST
        |STARTS_WITH
        |ENDS_WITH
        |MORELIKETHIS
        |INTERSECT
        |EXACT
    ) 
    OP_PAR 
        specialParam 
        (
            COMMA specialParam
        )* 
    CL_PAR
;

specialParam:
    specialParam EQUAL specialParam
    | variable BETWEEN specialParam
    | specialParam AND specialParam
    | specialParam OR specialParam
    | specialParam MATH specialParam
    | specialFunctions
    | custom_function
    | variable
    | STRING+
    | NUM;

parameterWithOptionalAlias:
      (
             custom_function
             |variable
        ) 
    alias?;

parameter:
        (
             custom_function
             |variable
        ) 
;
collectionName:
    WORD
    |STRING;

includeStatement:
    INCLUDE collectionName;

fromAlias:
    AS? WORD;